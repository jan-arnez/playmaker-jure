---
description: Should be used when extracting hardcoded labels from a component
alwaysApply: false
---
This project is set up with next-intl for internationalization.

Notes:
- There must not be any hardcoded strings in components.

- All extracted messages should be put into @en-US.json.

- All keys in @en-US.json must be sorted alphabetically.

- Components reference messages using useTranslations('ComponentName') (or await getTranslations('ComponentName') in async components) and call them with t('keyName').

- Use component names as namespaces for keys.

- Use descriptive and short names for keys that describe the intent instead of using the literal content (e.g. title, description).

- Use PascalCase for namespaces and camelCase for keys.

- Leave already translated strings as-is.

- Only touch component code, leave general setup files as-is.

- You should use the following ICU features to create flexible and user-friendly messages:
	1. Arguments (e.g. Hello {firstName})
		- Receive variables that are combined with text as primitive arguments so that translators can integrate them into the grammatical structure of a given language.


	2. Plurals (e.g. {count, plural, =0 {No reviews yet.} one {One customer has left a review.} other {# customers has left a review.}})
		- Improve the readability by processing the argument as part of the plural expression.
			- Wrong: {count} {count, plural, one {review} other {reviews}} (argument outside of plural expression)

			- Correct: {count, plural, =0 {No reviews yet.} one {One customer has left a review.} other {# customers has left a review.}}



	3. Select (e.g. {gender, select, male {He} female {She} other {They}} has left a review.)

	4. Rich text (e.g. See details in the <link>size guide</link>).
		- Extracted rich text must be used with t.rich instead of t.



Translating Zod Schemas


When translating Zod schemas, the translations should be organized based on the component's location and name, similar to other messages.

Rules for Zod Schema Translations:


- Location-based Namespace: Determine the top-level namespace based on the component's module.
	- If a component is located within /modules/admin, the top-level namespace in en-SI.json should be Auth (or another appropriate module-level identifier if Auth isn't fitting for the specific admin component).

	- If a component is in a shared folder or is considered global, the top-level namespace should be Global.


- Component-specific Keys: Below the top-level namespace, use the component name in camelCase as the next level of nesting.

- Descriptive Keys for Schema Errors: Inside the component-specific object, use descriptive camelCase keys for each Zod schema validation message.

Example 1 (Admin Module Component):

If your component is located at /modules/admin/components/PlatformLoginForm.tsx and contains a Zod schema, the structure in en-SI.json would be:


	{
	  "Auth": {
	    "platformLoginForm": {
	      "emailRequired": "Email is required.",
	      "emailInvalid": "Please enter a valid email address.",
	      "passwordRequired": "Password is required.",
	      "passwordMinLength": "Password must be at least {min} characters long."
	    }
	  }
	}

Example 2 (Shared/Global Component):

If your component is located at /components/shared/Modal.tsx (or is a globally accessible component) and contains a Zod schema (e.g., for a general contact form), the structure in en-SI.json would be:


	{
	  "Global": {
	    "contactForm": {
	      "nameRequired": "Name is required.",
	      "emailRequired": "Email is required.",
	      "emailInvalid": "Please enter a valid email address.",
	      "messageRequired": "Message cannot be empty."
	    }
	  }
	}